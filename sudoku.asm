$ SUDOKU PROGRAM WRITTEN IN MY SIMULATOR
MVI B, 0
CALL SUDOKU_SOLVE
HLT	$SUDOKU TO BE SOLVED => 8000 TO 8050

	$ CELL NO IS IN REGISTER B
	$ RETURN VALUE IS IN REGISTER C
SUDOKU_SOLVE:	MOV A, B
	CPI 81
	JNZ NEXT
	MVI C, 1		$ SUDOKU WAS SOLVED
	RET
NEXT: CALL READ_FROM_B
	CPI 0H
	JZ ITR
	INR B
	CALL SUDOKU_SOLVE
	DCR B
	RET
ITR:	PUSH D			$ E IS USED FOR COUNTER
	MVI E, 09H
LOOP:	CALL CANFILL		$I = REGISTER E, CELLNO = REGISTER B
	RRC
	JNC ITRNEXT
	$CAN FILL THE CELL
	MOV A, E
	CALL STORE_TO_B
	INR B			$INCREASE CELL
	CALL SUDOKU_SOLVE	$RECURSIVE CALL
	DCR B			$ DECREASE CELL
	MOV A, C		$CHECK IF SUDOKU WAS SOLVED
	RRC
	JNC ITRNEXT
	$ OK, THE SUDOKU WAS SOLVED
	JMP PREP_RET
ITRNEXT: DCR E
	JNZ LOOP
	XRA A			$ZERO THE ACCUMULATOR
	CALL STORE_TO_B		$STORE ZERO I.E. FOR BACKTRACKING
PREP_RET:	POP D
	RET

	$$ READS THE CONTENT AT THE SUDOKU CELL NO
	$$ SPECIFIED BY REGISTER B INTO THE ACCUMULATOR
READ_FROM_B:	PUSH H
	MVI H, 80H
	MOV L, B
	MOV A, M
	POP H
	RET
	$$STORES THE ACCUMULATOR CONTENT TO THE SUDOKU CELL
	$$ SPECIFIED BY REGISTER B
STORE_TO_B:	PUSH H
	MVI H, 80H
	MOV L, B
	MOV M, A
	POP H
	RET

	$$ SPECIFIED BY REGISTER A INTO THE ACCUMULATOR
READ_FROM_A:	PUSH H
	MVI H, 80H
	MOV L, A
	MOV A, M
	POP H
	RET
	
$ARGUMENT IS IN ACCUMULATOR
	
$RES IS IN ACCU
MULT_BY_3: PUSH B
MOV B, A
RLC
ADD B
POP B
RET

$ARGUMENT IS IN ACCU
$RES IS IN ACCU
MULT_BY_9: PUSH B
MOV B, A
RLC
RLC
RLC
ADD B
POP B
RET

	$$ RETURNS ROW IN H REGISTER, COL IN L REG
	$$ OF THE CELL NUMBER IN REGISTER B
GET_ROW_COL:	PUSH B
	LXI H, 00H
	MOV A, B
ITR_DIV:	CPI 9
	JC FINISH
	SBI 9
	INR H
	JMP ITR_DIV
FINISH:	MOV L, A
	POP B
	RET
	
	$$ RETURNS 1 IN THE ACCUMULATOR
	$$ IF VALUE AT REGISTER E CAN BE FILLED INTO THE
	$$ CELL NUMBER SPECIFIED BY REGISTER B
	$$ ELSE RETURNS ZERO
CANFILL: PUSH H			$SAVE REGISTERS
	PUSH B			$REGISTER C IS FREED TOO
	PUSH D			$D IS USED FOR COUNTER
	CALL GET_ROW_COL
	MVI C, 09H
LOOP1:	DCR C
	MOV A, H
	CALL MULT_BY_9
	ADD C
	CMP B
	JZ NEXTI
	CALL READ_FROM_A
	CMP E
	JNZ NEXTI
	MVI A, 0
	JMP RET_PREP
NEXTI:	MOV A, C
	CPI 0
	JNZ LOOP1
$NOW CHECK FOR DUPLICATE IN THE COLUMN
	MVI C, 09H
LOOP2:	DCR C
	MOV A, C
	CALL MULT_BY_9
	ADD L
	CMP B
	JZ NEXTI_2
	CALL READ_FROM_A
	CMP E
	JNZ NEXTI_2
	MVI A, 0
	JMP RET_PREP
NEXTI_2:	MOV A, C
	CPI 0
	JNZ LOOP2
	$$ 3X3 BOX CHECK
	MOV A, H
	CALL DIV_AND_MULT_BY_3
	MOV H, A
	MOV A, L
	CALL DIV_AND_MULT_BY_3
	MOV L, A
	MVI C, 03H
GRIDOUT:	DCR C
	MVI D, 03H
GRIDIN:	DCR D
	MOV A, H
	ADD C
	CALL MULT_BY_9
	ADD L
	ADD D
	CMP B
	JZ PREP_OUT		
	CALL READ_FROM_A
	CMP E
	JNZ PREP_OUT
	MVI A, 0
	JMP RET_PREP
PREP_OUT:	MOV A, D
	CPI 0H
	JNZ GRIDIN
	MOV A, C
	CPI 0H
	JNZ GRIDOUT
	MVI A, 1H
RET_PREP:	POP D
	POP B
	POP H
	RET

	$ RETURN VALUE IS A = (A / 3) * 3, WHERE A IS THE
	$ ACCUMULATOR, RETURN VALUE IS PLACED ON THE ACCUMU
	$ LATOR
	$ DATA BOUNDARY FOR INPUT ARGUMENT TO THIS FUNCTION
	$ [0, 9)
	
DIV_AND_MULT_BY_3: CPI 6H
	JNC GR_6
	CPI 3H
	JNC GR_3
	XRA A			$IS 0
	JMP OK_OUT
GR_6:	MVI A, 2H		$IS 1
	JMP OK_OUT
GR_3:	MVI A, 1H		$IS 2
OK_OUT:	CALL MULT_BY_3
	RET
